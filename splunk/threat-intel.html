<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <title>Threat Intelligence - SOC Compendium</title>
    <link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
    <nav class="main-nav">
        <div class="nav-container">
            <div class="nav-logo">SOC Compendium</div>
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>
                <li><a href="../cortex/index.html">Cortex XDR</a></li>
                <li><a href="../crowdstrike/index.html">CrowdStrike</a></li>
                <li><a href="../mde/index.html">Microsoft Defender</a></li>
                <li><a href="../sentinel/index.html">Sentinel</a></li>
                <li><a href="index.html" class="active">Splunk</a></li>
                <li><a href="../operations/index.html">Operations</a></li>
            </ul>
        </div>
    </nav>

    <main class="content">
        <div class="content-header">
            <h1>Threat Intelligence</h1>
            <p class="subtitle">Integrating and operationalizing threat intelligence in Splunk ES</p>
        </div>

        <section class="doc-section">
            <h2>Threat Intelligence Overview</h2>
            <p>Splunk Enterprise Security's Threat Intelligence framework enables ingestion, normalization, and correlation of threat indicators from multiple sources. Effective threat intelligence integration transforms raw IOCs into actionable detections that enhance security visibility.</p>

            <div class="info-box">
                <h4>ES Threat Intelligence Capabilities</h4>
                <ul>
                    <li><strong>Multi-Source Ingestion:</strong> Support for STIX/TAXII, CSV, OpenIOC, and custom formats</li>
                    <li><strong>Automatic Correlation:</strong> Real-time matching against network, endpoint, and identity data</li>
                    <li><strong>Threat Intelligence Manager:</strong> Central console for managing feeds and indicators</li>
                    <li><strong>Risk Integration:</strong> Threat matches contribute to entity risk scores</li>
                    <li><strong>Intelligence Enrichment:</strong> Context addition for investigations</li>
                </ul>
            </div>
        </section>

        <section class="doc-section">
            <h2>Threat Intelligence Architecture</h2>

            <h3>ES Threat Intelligence Components</h3>
            <div class="info-box">
                <h4>Architecture Overview</h4>
                <p><strong>Threat Feeds → Downloaders → KV Store Collections → Correlation Searches → Notable Events</strong></p>
                <ul>
                    <li><strong>Threat Downloaders:</strong> Scheduled inputs that retrieve indicators from external sources</li>
                    <li><strong>Threat Gen:</strong> Processing scripts that normalize indicators into standard format</li>
                    <li><strong>KV Store Collections:</strong> High-performance lookups storing active indicators</li>
                    <li><strong>Threat Matching:</strong> Correlation searches that match indicators against live data</li>
                    <li><strong>Threat Activity:</strong> Index storing all threat intelligence matches</li>
                </ul>
            </div>

            <h3>KV Store Collections for Threat Intel</h3>
            <div class="styled-table">
                <table>
                    <thead>
                        <tr>
                            <th>Collection</th>
                            <th>Contents</th>
                            <th>Key Fields</th>
                            <th>Typical Size</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>ip_intel</code></td>
                            <td>Malicious IP addresses</td>
                            <td>ip, threat_key, description, weight</td>
                            <td>100K-10M entries</td>
                        </tr>
                        <tr>
                            <td><code>domain_intel</code></td>
                            <td>Malicious domains</td>
                            <td>domain, threat_key, description, weight</td>
                            <td>50K-5M entries</td>
                        </tr>
                        <tr>
                            <td><code>file_intel</code></td>
                            <td>File hashes (MD5, SHA1, SHA256)</td>
                            <td>file_hash, file_name, threat_key, weight</td>
                            <td>500K-50M entries</td>
                        </tr>
                        <tr>
                            <td><code>url_intel</code></td>
                            <td>Malicious URLs</td>
                            <td>url, threat_key, description, weight</td>
                            <td>100K-5M entries</td>
                        </tr>
                        <tr>
                            <td><code>email_intel</code></td>
                            <td>Malicious email addresses/subjects</td>
                            <td>src_user, subject, threat_key, weight</td>
                            <td>10K-500K entries</td>
                        </tr>
                        <tr>
                            <td><code>http_intel</code></td>
                            <td>Malicious HTTP attributes</td>
                            <td>http_user_agent, http_referrer, weight</td>
                            <td>5K-100K entries</td>
                        </tr>
                        <tr>
                            <td><code>registry_intel</code></td>
                            <td>Suspicious registry keys/values</td>
                            <td>registry_path, registry_value_name, weight</td>
                            <td>1K-50K entries</td>
                        </tr>
                        <tr>
                            <td><code>process_intel</code></td>
                            <td>Suspicious process indicators</td>
                            <td>process_name, process_path, weight</td>
                            <td>1K-20K entries</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="doc-section">
            <h2>Configuring Threat Intelligence Sources</h2>

            <h3>STIX/TAXII Feed Configuration</h3>
            <p>STIX/TAXII is the industry standard for threat intelligence sharing. ES supports TAXII 1.x and 2.x protocols.</p>

            <div class="code-block">
                <div class="code-header">TAXII 2.x Feed Configuration (inputs.conf)</div>
                <pre>[threatlist://taxii2_example]
description = Example TAXII 2.x Feed
disabled = 0
interval = 3600
type = taxii2
url = https://taxii.example.com/taxii2/
collection = example_collection
api_root = https://taxii.example.com/api/
username = api_user
password = api_password
# Optional: Certificate-based auth
# client_cert = /path/to/cert.pem
# client_key = /path/to/key.pem

# TAXII 1.x Configuration
[threatlist://taxii1_example]
description = Example TAXII 1.x Feed
disabled = 0
interval = 3600
type = taxii
url = https://taxii.example.com/services/poll
collection = example_collection
username = api_user
password = api_password
cert_file = /path/to/cert.pem
key_file = /path/to/key.pem</pre>
            </div>

            <h3>CSV Threat Feed Configuration</h3>
            <div class="code-block">
                <div class="code-header">CSV Feed Setup (inputs.conf)</div>
                <pre># Remote CSV Feed
[threatlist://csv_ip_blocklist]
description = External IP Blocklist
disabled = 0
interval = 86400
type = threatlist
url = https://feeds.example.com/ip_blocklist.csv
# Field mappings
threat_key = src_feed_name
ip = column1
description = column2
weight = 2

# Local CSV Feed
[threatlist://local_custom_iocs]
description = Internal IOC List
disabled = 0
interval = 3600
type = threatlist
url = file:///opt/splunk/etc/apps/SA-ThreatIntelligence/local/data/custom_iocs.csv
delim_regex = ,
fields = ip,description,threat_category,date_added
threat_key = custom_internal_feed
weight = 3

# Expected CSV Format:
# ip,description,threat_category,date_added
# 192.168.1.100,Known C2 server,c2,2024-01-15
# 10.0.0.50,Compromised host,compromised,2024-01-14</pre>
            </div>

            <h3>Custom API Integration</h3>
            <div class="code-block">
                <div class="code-header">Modular Input for Custom API (Python)</div>
                <pre>#!/usr/bin/env python3
"""
Custom Threat Intelligence Modular Input
Fetches indicators from custom API and outputs to Splunk
"""

import sys
import json
import requests
from splunklib.modularinput import Script, Scheme, Argument, Event

class ThreatFeedInput(Script):
    def get_scheme(self):
        scheme = Scheme("Custom Threat Feed")
        scheme.description = "Ingests threat intelligence from custom API"
        scheme.use_external_validation = False
        scheme.use_single_instance = True
        
        scheme.add_argument(Argument(
            name="api_url",
            description="API endpoint URL",
            data_type=Argument.data_type_string,
            required_on_create=True
        ))
        scheme.add_argument(Argument(
            name="api_key",
            description="API authentication key",
            data_type=Argument.data_type_string,
            required_on_create=True
        ))
        return scheme

    def stream_events(self, inputs, ew):
        for input_name, input_item in inputs.inputs.items():
            api_url = input_item["api_url"]
            api_key = input_item["api_key"]
            
            headers = {
                "Authorization": f"Bearer {api_key}",
                "Accept": "application/json"
            }
            
            try:
                response = requests.get(api_url, headers=headers, timeout=60)
                response.raise_for_status()
                indicators = response.json()
                
                for indicator in indicators.get("data", []):
                    # Transform to ES threat intel format
                    event_data = {
                        "threat_key": "custom_feed",
                        "ip": indicator.get("ip"),
                        "domain": indicator.get("domain"),
                        "file_hash": indicator.get("hash"),
                        "description": indicator.get("description"),
                        "threat_category": indicator.get("category"),
                        "weight": indicator.get("severity", 1),
                        "time": indicator.get("timestamp")
                    }
                    
                    # Remove None values
                    event_data = {k: v for k, v in event_data.items() if v}
                    
                    event = Event()
                    event.data = json.dumps(event_data)
                    event.sourcetype = "threat_intel_custom"
                    ew.write_event(event)
                    
            except Exception as e:
                ew.log("ERROR", f"Failed to fetch threat intel: {str(e)}")

if __name__ == "__main__":
    sys.exit(ThreatFeedInput().run(sys.argv))</pre>
            </div>

            <h3>Feed Weight and Priority Configuration</h3>
            <div class="styled-table">
                <table>
                    <thead>
                        <tr>
                            <th>Weight</th>
                            <th>Priority Level</th>
                            <th>Use Case</th>
                            <th>Example Sources</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Low</td>
                            <td>Background enrichment, minimal action</td>
                            <td>Open source feeds, unvetted lists</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>Medium-Low</td>
                            <td>Investigation support, watchlist</td>
                            <td>Community feeds, aged indicators</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Medium</td>
                            <td>Notable event generation, analyst review</td>
                            <td>Commercial feeds, ISAC sharing</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Medium-High</td>
                            <td>Priority alerting, immediate investigation</td>
                            <td>Premium intel providers, curated feeds</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>High</td>
                            <td>Critical alerts, potential automated response</td>
                            <td>Internal confirmed IOCs, active incident</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="doc-section">
            <h2>Threat Intelligence Lookups</h2>

            <h3>Lookup Configuration</h3>
            <div class="code-block">
                <div class="code-header">transforms.conf - Threat Intel Lookups</div>
                <pre># IP Intelligence Lookup
[ip_intel]
collection = ip_intel
external_type = kvstore
fields_list = _key, description, ip, threat_category, 
              threat_key, time, weight

# Domain Intelligence Lookup  
[domain_intel]
collection = domain_intel
external_type = kvstore
fields_list = _key, description, domain, threat_category,
              threat_key, time, weight

# File Intelligence Lookup
[file_intel]
collection = file_intel
external_type = kvstore
fields_list = _key, description, file_hash, file_name,
              threat_category, threat_key, time, weight

# URL Intelligence Lookup
[url_intel]
collection = url_intel
external_type = kvstore
fields_list = _key, description, url, threat_category,
              threat_key, time, weight

# Certificate Intelligence (for certificate pinning/abuse)
[certificate_intel]
collection = certificate_intel
external_type = kvstore
fields_list = _key, description, ssl_serial, ssl_subject_common_name,
              ssl_issuer_common_name, threat_key, time, weight</pre>
            </div>

            <h3>Manual Lookup Operations</h3>
            <div class="code-block">
                <div class="code-header">SPL Lookup Examples</div>
                <pre># Check if IP exists in threat intel
| makeresults 
| eval ip="192.168.1.100"
| lookup ip_intel ip OUTPUT threat_key, description, weight
| table ip, threat_key, description, weight

# Bulk check multiple IPs
| inputlookup my_suspicious_ips.csv
| lookup ip_intel ip OUTPUT threat_key, description, weight as threat_weight
| where isnotnull(threat_key)
| table ip, threat_key, description, threat_weight

# Check domain against threat intel
index=proxy sourcetype=squid
| stats count by site
| lookup domain_intel domain as site 
    OUTPUT threat_key, description, threat_category
| where isnotnull(threat_key)
| table site, count, threat_key, threat_category, description

# Check file hashes against threat intel
index=endpoint sourcetype=sysmon EventCode=1
| stats count by Hashes
| rex field=Hashes "SHA256=(?<sha256>[A-Fa-f0-9]{64})"
| lookup file_intel file_hash as sha256 
    OUTPUT threat_key, description, file_name
| where isnotnull(threat_key)
| table sha256, threat_key, description, file_name, count</pre>
            </div>

            <h3>Adding Custom Indicators</h3>
            <div class="code-block">
                <div class="code-header">Adding IOCs via SPL</div>
                <pre># Add single IP indicator
| makeresults
| eval ip="10.0.0.100",
       description="Confirmed C2 server from incident INC-2024-001",
       threat_key="internal_confirmed",
       threat_category="c2",
       weight=5,
       time=now()
| outputlookup append=true ip_intel

# Add multiple domain indicators
| makeresults count=3
| streamstats count as row
| eval domain=case(
    row=1, "malicious-domain1.com",
    row=2, "malicious-domain2.net",
    row=3, "malicious-domain3.org"
  ),
  description="Associated with phishing campaign PHI-2024-015",
  threat_key="internal_phishing",
  threat_category="phishing",
  weight=4,
  time=now()
| outputlookup append=true domain_intel

# Add file hash indicators from investigation
| inputlookup incident_malware_hashes.csv
| eval threat_key="incident_INC-2024-002",
       threat_category="malware",
       weight=5,
       time=now()
| outputlookup append=true file_intel

# Remove expired indicators (older than 90 days)
| inputlookup ip_intel
| where time > relative_time(now(), "-90d")
| outputlookup ip_intel</pre>
            </div>

            <div class="code-block">
                <div class="code-header">REST API for Indicator Management</div>
                <pre># Add indicator via REST API
curl -k -u admin:password \
  https://splunk:8089/servicesNS/nobody/SA-ThreatIntelligence/storage/collections/data/ip_intel \
  -H "Content-Type: application/json" \
  -d '{
    "ip": "192.168.100.50",
    "description": "Newly identified C2",
    "threat_key": "api_upload",
    "threat_category": "c2",
    "weight": 4,
    "time": 1705344000
  }'

# Bulk add indicators
curl -k -u admin:password \
  https://splunk:8089/servicesNS/nobody/SA-ThreatIntelligence/storage/collections/data/ip_intel/batch_save \
  -H "Content-Type: application/json" \
  -d '[
    {"ip": "10.0.0.1", "threat_key": "batch", "weight": 3},
    {"ip": "10.0.0.2", "threat_key": "batch", "weight": 3},
    {"ip": "10.0.0.3", "threat_key": "batch", "weight": 3}
  ]'

# Delete specific indicator
curl -k -u admin:password -X DELETE \
  "https://splunk:8089/servicesNS/nobody/SA-ThreatIntelligence/storage/collections/data/ip_intel?query=%7B%22ip%22%3A%22192.168.100.50%22%7D"</pre>
            </div>
        </section>

        <section class="doc-section">
            <h2>Threat Matching and Correlation</h2>

            <h3>ES Built-in Threat Correlation Searches</h3>
            <div class="styled-table">
                <table>
                    <thead>
                        <tr>
                            <th>Correlation Search</th>
                            <th>Data Source</th>
                            <th>Indicators Matched</th>
                            <th>Default Schedule</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Threat Activity Detected</td>
                            <td>Network Traffic</td>
                            <td>IP, Domain</td>
                            <td>Every 5 minutes</td>
                        </tr>
                        <tr>
                            <td>Threat Activity Detected - Email</td>
                            <td>Email logs</td>
                            <td>Email addresses, subjects</td>
                            <td>Every 5 minutes</td>
                        </tr>
                        <tr>
                            <td>Threat Activity Detected - Endpoint</td>
                            <td>Endpoint logs</td>
                            <td>File hashes, processes</td>
                            <td>Every 5 minutes</td>
                        </tr>
                        <tr>
                            <td>Threat Activity Detected - Web</td>
                            <td>Web proxy logs</td>
                            <td>URLs, domains, user agents</td>
                            <td>Every 5 minutes</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Custom Threat Correlation Searches</h3>
            <div class="code-block">
                <div class="code-header">IP Threat Match Correlation</div>
                <pre># High-Fidelity IP Threat Match
| tstats summariesonly=t count, values(All_Traffic.dest_port) as dest_ports,
    values(All_Traffic.action) as actions, dc(All_Traffic.dest) as dest_count
    FROM datamodel=Network_Traffic 
    WHERE All_Traffic.action=allowed
    BY All_Traffic.src, All_Traffic.dest, _time span=5m
| rename All_Traffic.* as *
| lookup ip_intel ip as dest OUTPUT threat_key, description, 
    threat_category, weight as dest_threat_weight
| lookup ip_intel ip as src OUTPUT threat_key as src_threat_key, 
    description as src_description, weight as src_threat_weight
| where isnotnull(dest_threat_weight) OR isnotnull(src_threat_weight)
| eval threat_weight=coalesce(dest_threat_weight, src_threat_weight),
       threat_key=coalesce(threat_key, src_threat_key),
       threat_direction=if(isnotnull(dest_threat_weight), "outbound_to_threat", "inbound_from_threat")
| where threat_weight >= 3
| stats count as event_count, values(dest_ports) as ports,
    values(threat_category) as threat_category, latest(description) as intel_description,
    values(threat_direction) as direction by src, dest, threat_key, threat_weight
| eval urgency=case(
    threat_weight>=5, "critical",
    threat_weight>=4, "high",
    threat_weight>=3, "medium",
    1=1, "low"
  )</pre>
            </div>

            <div class="code-block">
                <div class="code-header">Domain Threat Match with Context</div>
                <pre># DNS Query to Malicious Domain
| tstats summariesonly=t count, values(DNS.src) as sources,
    dc(DNS.src) as unique_sources
    FROM datamodel=Network_Resolution
    WHERE DNS.message_type=QUERY
    BY DNS.query, _time span=1h
| rename DNS.* as *
| lookup domain_intel domain as query 
    OUTPUT threat_key, description, threat_category, weight
| where isnotnull(threat_key)
| eval urgency=case(
    weight>=5 AND unique_sources>=5, "critical",
    weight>=4 OR unique_sources>=10, "high",
    weight>=3, "medium",
    1=1, "low"
  )
| where urgency IN ("critical", "high", "medium")
| eval description="DNS queries to known malicious domain: ".query.
       " (Source: ".threat_key."). ".coalesce(description, "")
| table _time, query, threat_key, threat_category, count, 
    unique_sources, sources, urgency, description</pre>
            </div>

            <div class="code-block">
                <div class="code-header">File Hash Threat Match on Endpoints</div>
                <pre># Process Execution with Known Malicious Hash
index=endpoint sourcetype=sysmon EventCode=1
| rex field=Hashes "(?:SHA256|sha256)=(?<sha256>[A-Fa-f0-9]{64})"
| rex field=Hashes "(?:MD5|md5)=(?<md5>[A-Fa-f0-9]{32})"
| eval file_hash=coalesce(sha256, md5)
| lookup file_intel file_hash OUTPUT threat_key, description, 
    threat_category, file_name as known_malware_name, weight
| where isnotnull(threat_key)
| eval urgency=case(
    weight>=5, "critical",
    weight>=4, "high",
    1=1, "medium"
  )
| stats count as execution_count, values(User) as users,
    values(ParentCommandLine) as parent_commands,
    values(CommandLine) as commands,
    latest(_time) as last_seen
    by ComputerName, file_hash, Image, threat_key, known_malware_name, urgency
| eval description="Execution of known malicious file: ".
    coalesce(known_malware_name, Image)." (Hash: ".file_hash.")"
| sort - urgency, - execution_count</pre>
            </div>

            <div class="code-block">
                <div class="code-header">Multi-Indicator Correlation</div>
                <pre># Combined Threat Intelligence Match Across Data Sources
# This search correlates multiple indicator types for comprehensive coverage

# Part 1: Network threats
| tstats summariesonly=t count 
    FROM datamodel=Network_Traffic BY All_Traffic.src, All_Traffic.dest
| rename All_Traffic.* as *
| eval indicator_type="ip", indicator=dest
| lookup ip_intel ip as dest OUTPUT threat_key, description, weight
| where isnotnull(threat_key)
| eval match_type="network_dest"
| append [
    # Part 2: DNS threats
    | tstats summariesonly=t count FROM datamodel=Network_Resolution 
        BY DNS.src, DNS.query
    | rename DNS.* as *
    | eval indicator_type="domain", indicator=query
    | lookup domain_intel domain as query OUTPUT threat_key, description, weight
    | where isnotnull(threat_key)
    | eval match_type="dns_query"
]
| append [
    # Part 3: Web threats
    | tstats summariesonly=t count FROM datamodel=Web 
        BY Web.src, Web.url, Web.site
    | rename Web.* as *
    | lookup domain_intel domain as site OUTPUT threat_key, description, weight
    | where isnotnull(threat_key)
    | eval indicator_type="domain", indicator=site, match_type="web_request"
]
| stats count as total_matches, values(match_type) as match_types,
    values(indicator) as indicators, max(weight) as max_weight
    BY src, threat_key
| where max_weight >= 3 AND total_matches >= 2
| eval urgency=case(
    max_weight>=5 AND total_matches>=5, "critical",
    max_weight>=4 OR total_matches>=10, "high",
    1=1, "medium"
  )
| table src, threat_key, indicators, match_types, total_matches, 
    max_weight, urgency</pre>
            </div>
        </section>

        <section class="doc-section">
            <h2>Threat Intelligence Management</h2>

            <h3>Feed Health Monitoring</h3>
            <div class="code-block">
                <div class="code-header">Threat Feed Health Dashboard Queries</div>
                <pre># Feed update status
| rest /services/data/inputs/threatlist
| table title, disabled, interval, type, url
| eval status=if(disabled=0, "Active", "Disabled")
| eval update_frequency_hours=round(interval/3600, 1)
| table title, status, type, update_frequency_hours, url

# Indicators per feed/source
| inputlookup ip_intel
| stats count by threat_key
| sort - count
| append [
    | inputlookup domain_intel
    | stats count by threat_key
    | sort - count
]
| append [
    | inputlookup file_intel
    | stats count by threat_key
    | sort - count
]
| stats sum(count) as indicator_count by threat_key
| sort - indicator_count

# Indicator age distribution
| inputlookup ip_intel
| eval age_days=round((now()-time)/86400, 0)
| eval age_bucket=case(
    age_days<=7, "0-7 days",
    age_days<=30, "8-30 days",
    age_days<=90, "31-90 days",
    1=1, "90+ days"
  )
| stats count by age_bucket
| sort age_bucket

# Stale feeds detection (no new indicators in 7 days)
| inputlookup ip_intel
| stats max(time) as last_update by threat_key
| eval days_since_update=round((now()-last_update)/86400, 1)
| where days_since_update > 7
| sort - days_since_update
| eval status="⚠️ Stale"
| table threat_key, days_since_update, status</pre>
            </div>

            <h3>Threat Intel Effectiveness Metrics</h3>
            <div class="code-block">
                <div class="code-header">Measuring Threat Intel Value</div>
                <pre># Match rate by feed
index=threat_activity earliest=-30d
| stats count as matches, dc(threat_match_field) as unique_indicators,
    dc(src) as unique_sources by threat_key
| join type=left threat_key [
    | inputlookup ip_intel | stats count as ip_indicators by threat_key
    | append [| inputlookup domain_intel | stats count as domain_indicators by threat_key]
    | append [| inputlookup file_intel | stats count as file_indicators by threat_key]
    | stats sum(ip_indicators) as ip_count, sum(domain_indicators) as domain_count,
            sum(file_indicators) as file_count by threat_key
    | eval total_indicators=ip_count+domain_count+file_count
]
| eval match_rate_pct=round(unique_indicators/total_indicators*100, 2)
| table threat_key, matches, unique_indicators, total_indicators, 
    match_rate_pct, unique_sources
| sort - matches

# True Positive Rate by feed (requires analyst feedback)
index=notable rule_name="*Threat*" earliest=-90d
| stats count as total_alerts,
    count(eval(status_label="Resolved - True Positive")) as true_positives,
    count(eval(status_label="Resolved - False Positive")) as false_positives
    by threat_key
| eval tp_rate=round(true_positives/(true_positives+false_positives)*100, 1)
| where total_alerts > 10
| table threat_key, total_alerts, true_positives, false_positives, tp_rate
| sort - tp_rate

# Time-to-detection analysis
index=threat_activity
| lookup threat_first_seen.csv indicator OUTPUT first_seen_global
| eval detection_lag_hours=round((_time-first_seen_global)/3600, 1)
| stats avg(detection_lag_hours) as avg_detection_lag,
    median(detection_lag_hours) as median_detection_lag,
    count as detections by threat_key
| where detections > 5
| sort avg_detection_lag</pre>
            </div>

            <h3>Indicator Lifecycle Management</h3>
            <div class="code-block">
                <div class="code-header">Indicator Expiration and Cleanup</div>
                <pre># Automated cleanup savedsearch (run daily)
# Remove indicators older than retention period by feed type

# Premium feeds: 180 days retention
| inputlookup ip_intel
| where threat_key IN ("premium_feed_1", "premium_feed_2")
| where time > relative_time(now(), "-180d")
| outputlookup ip_intel_premium_temp

# Standard feeds: 90 days retention
| inputlookup ip_intel
| where NOT threat_key IN ("premium_feed_1", "premium_feed_2", "internal_confirmed")
| where time > relative_time(now(), "-90d")
| outputlookup ip_intel_standard_temp

# Internal confirmed: No automatic expiration (manual review required)
| inputlookup ip_intel
| where threat_key="internal_confirmed"
| outputlookup ip_intel_internal_temp

# Merge back (run as separate search or via script)
# | inputlookup ip_intel_premium_temp
# | append [| inputlookup ip_intel_standard_temp]
# | append [| inputlookup ip_intel_internal_temp]
# | outputlookup ip_intel

# Report on indicators removed
| inputlookup ip_intel
| where time < relative_time(now(), "-90d")
| stats count by threat_key
| eval action="Will be removed"
| table threat_key, count, action</pre>
            </div>
        </section>

        <section class="doc-section">
            <h2>Advanced Threat Intelligence Use Cases</h2>

            <h3>MITRE ATT&CK Integration</h3>
            <div class="code-block">
                <div class="code-header">Enrich Threat Intel with MITRE Mapping</div>
                <pre># Add MITRE ATT&CK context to threat matches
index=threat_activity
| lookup mitre_attack_techniques.csv threat_category 
    OUTPUT mitre_tactic, mitre_technique, mitre_technique_id
| stats count as matches,
    values(mitre_tactic) as tactics,
    values(mitre_technique_id) as techniques
    by threat_key, src
| mvexpand tactics
| stats count as tactic_hits by tactics
| sort - tactic_hits

# Create MITRE heatmap from threat intel matches
index=threat_activity earliest=-30d
| lookup mitre_attack_techniques.csv threat_category 
    OUTPUT mitre_tactic_id, mitre_technique_id
| stats count as hits by mitre_tactic_id, mitre_technique_id
| eval coverage=case(
    hits>=100, "High",
    hits>=10, "Medium",
    hits>=1, "Low",
    1=1, "None"
  )</pre>
            </div>

            <h3>Threat Intel Pivoting for Investigations</h3>
            <div class="code-block">
                <div class="code-header">Investigation Enrichment Workflow</div>
                <pre># Given a suspicious IP, find related indicators
| makeresults 
| eval investigation_ip="192.168.100.50"

# Check threat intel for direct match
| append [
    | inputlookup ip_intel 
    | search ip="192.168.100.50"
    | eval match_type="direct_intel_match"
]

# Find historical activity from this IP
| append [
    | tstats count FROM datamodel=Network_Traffic 
        WHERE All_Traffic.src="192.168.100.50" 
        BY All_Traffic.dest earliest=-30d
    | rename All_Traffic.dest as ip
    | lookup ip_intel ip OUTPUT threat_key, description
    | where isnotnull(threat_key)
    | eval match_type="dest_communicated_with"
]

# Find domains resolved to this IP
| append [
    | tstats count FROM datamodel=Network_Resolution
        WHERE DNS.answer="192.168.100.50"
        BY DNS.query earliest=-30d
    | rename DNS.query as domain
    | lookup domain_intel domain OUTPUT threat_key, description
    | eval match_type="domain_resolved_to_ip"
]

# Check file hashes seen on systems communicating with this IP
| append [
    index=endpoint sourcetype=sysmon EventCode=3 DestinationIp="192.168.100.50"
    | stats values(Hashes) as file_hashes by ComputerName
    | mvexpand file_hashes
    | rex field=file_hashes "SHA256=(?<sha256>[A-Fa-f0-9]{64})"
    | lookup file_intel file_hash as sha256 OUTPUT threat_key, description, file_name
    | where isnotnull(threat_key)
    | eval match_type="file_hash_on_communicating_host"
]
| table match_type, ip, domain, sha256, threat_key, description</pre>
            </div>

            <h3>Automated IOC Extraction from Incidents</h3>
            <div class="code-block">
                <div class="code-header">Extract and Add IOCs from Notable Events</div>
                <pre># Extract IOCs from closed true positive incidents and add to internal feed
index=notable status_label="Resolved - True Positive" 
    rule_name="*Suspicious*" earliest=-7d
| rex field=_raw "(?<extracted_ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"
| rex field=_raw "(?<extracted_domain>[a-zA-Z0-9][-a-zA-Z0-9]*\.[a-zA-Z]{2,})"
| rex field=_raw "(?<extracted_sha256>[A-Fa-f0-9]{64})"
| rex field=_raw "(?<extracted_md5>[A-Fa-f0-9]{32})"

# Deduplicate and validate
| stats values(extracted_ip) as ips, values(extracted_domain) as domains,
    values(extracted_sha256) as sha256_hashes, values(extracted_md5) as md5_hashes,
    values(rule_name) as source_rules, latest(event_id) as incident_id
| mvexpand ips
| where NOT cidrmatch("10.0.0.0/8", ips) AND NOT cidrmatch("192.168.0.0/16", ips) 
    AND NOT cidrmatch("172.16.0.0/12", ips)
| eval indicator_type="ip", indicator=ips
| append [
    # Same for domains
    | search index=notable status_label="Resolved - True Positive" earliest=-7d
    | rex field=_raw "(?<extracted_domain>[a-zA-Z0-9][-a-zA-Z0-9]*\.[a-zA-Z]{2,})"
    | mvexpand extracted_domain
    | where NOT match(extracted_domain, "\.local$|\.internal$")
    | eval indicator_type="domain", indicator=extracted_domain
]
| stats count as occurrences, values(source_rules) as sources by indicator_type, indicator
| where occurrences >= 2
| eval threat_key="auto_extracted_from_incidents",
       weight=3,
       description="Auto-extracted from ".occurrences." confirmed incidents",
       time=now()
| table indicator_type, indicator, threat_key, weight, description, time</pre>
            </div>
        </section>

        <section class="doc-section">
            <h2>Interview Questions</h2>
            
            <div class="qa-box">
                <h4>Q: How do you evaluate and prioritize threat intelligence feeds for a SOC?</h4>
                <p><strong>A:</strong> I evaluate feeds on several criteria: First, relevance to our environment—a feed focused on financial sector threats is more valuable to a bank than generic feeds. Second, indicator quality and freshness—I look at false positive rates, how quickly new threats appear, and indicator hygiene (properly formatted, deduplicated). Third, context richness—feeds that include MITRE ATT&CK mapping, threat actor attribution, and detailed descriptions enable better response. Fourth, operational fit—STIX/TAXII feeds integrate cleanly with ES versus proprietary formats requiring custom parsers. I assign weights (1-5) based on these factors: internal confirmed IOCs get weight 5, premium commercial feeds 4, vetted community feeds 3, and open source feeds 1-2. I also track match rates and true positive rates over time to continuously evaluate feed value and adjust weights accordingly.</p>
            </div>

            <div class="qa-box">
                <h4>Q: Describe how you would handle a high-volume threat intel match scenario.</h4>
                <p><strong>A:</strong> High-volume matches often indicate either a very active threat or a noisy indicator. First, I assess the indicator quality—a domain on many blocklists might be a sinkhole or parking page generating false positives. I check the indicator age and source reliability. If legitimate, I prioritize by: entity criticality (executive workstations before test systems), match weight (internal confirmed over open source), and behavioral context (is there additional suspicious activity?). I implement aggregation in correlation searches to create one notable per entity rather than per event, reducing noise while maintaining visibility. For persistent high-volume scenarios, I consider promoting indicators to network-level blocking rather than just alerting. I also verify our data model acceleration is handling the lookup volume and adjust search schedules if needed to prevent queue buildup.</p>
            </div>

            <div class="qa-box">
                <h4>Q: How do you maintain threat intelligence hygiene in Splunk ES?</h4>
                <p><strong>A:</strong> Threat intel hygiene involves several ongoing processes. I implement automated expiration based on indicator type and source—IP addresses expire faster (30-90 days) than file hashes (180 days) because IPs are more dynamic. I run daily reports on stale feeds (no updates in 7+ days) to catch feed failures early. I deduplicate indicators when multiple feeds provide the same IOC, keeping the highest-confidence version. I validate indicator format before ingestion—malformed IPs or invalid domains create lookup errors. For internal indicators, I require incident references and review dates. I track false positive rates by feed and remove or reduce weight for feeds consistently generating FPs. Quarterly, I review all feeds for continued relevance and remove feeds that haven't produced true positives. I also monitor KV store collection sizes to ensure we're not approaching storage limits.</p>
            </div>

            <div class="qa-box">
                <h4>Q: How would you integrate a custom threat intelligence API with Splunk ES?</h4>
                <p><strong>A:</strong> I'd create a modular input to handle the integration. First, I analyze the API—authentication method (API key, OAuth, certificate), response format (JSON, CSV, STIX), rate limits, and pagination. I write a Python script that authenticates, retrieves indicators, normalizes them to ES format (threat_key, indicator fields, weight, description, time), and outputs as JSON events. The script handles errors gracefully—retries on transient failures, alerts on persistent issues. I configure it in inputs.conf with appropriate interval based on feed update frequency. For the downloaded data, I use a transform to route it to the appropriate KV store collection. I implement field extractions in props.conf if needed. Finally, I validate by checking the collection count increases after runs and verify matches generate correctly in threat_activity. I document the integration thoroughly including troubleshooting steps for feed failures.</p>
            </div>

            <div class="qa-box">
                <h4>Q: How do you measure the effectiveness of your threat intelligence program?</h4>
                <p><strong>A:</strong> I track several key metrics: Match rate shows what percentage of indicators actually match our environment data—very low rates might indicate irrelevant feeds. True positive rate measures analyst-confirmed matches versus false positives per feed, helping identify noisy sources. Detection coverage shows how much of our network/endpoint activity is being correlated against threat intel. Time-to-detection measures the lag between an indicator appearing in feeds and us detecting it in our environment. Cost per detection divides feed costs by true positive count for ROI analysis. I also track unique threats detected—feeds that only match threats already caught by other feeds provide less value. These metrics go into quarterly reviews where I recommend feed additions, removals, or weight adjustments. I present executive summaries showing how threat intel contributed to preventing or quickly detecting real incidents.</p>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="notable-events.html" class="btn btn-secondary">← Notable Events</a>
            <a href="troubleshooting.html" class="btn btn-primary">Troubleshooting →</a>
        </div>
    </main>

    <footer class="main-footer">
        <p>&copy; 2024 SOC Compendium. For educational purposes.</p>
    </footer>
</body>
</html>
